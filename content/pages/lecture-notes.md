---
content_type: page
title: Lecture Notes
uid: f492f5bb-8d3c-f429-82c3-260e683f5f34
---

Lectures 15, 21, and 22 were given by guest lecturer Dr. Victor Luchangco of Sun Microsystems, and are used with permission.

{{< tableopen >}}
{{< theadopen >}}
{{< tropen >}}
{{< thopen >}}
SES #
{{< thclose >}}
{{< thopen >}}
TOPICS
{{< thclose >}}
{{< thopen >}}
LECTURE NOTES
{{< thclose >}}

{{< trclose >}}

{{< theadclose >}}
{{< tropen >}}
{{< tdopen >}}
1
{{< tdclose >}}
{{< tdopen >}}
Course overview. Synchronous networks. Leader election in synchronous ring networks.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec01))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
2
{{< tdclose >}}
{{< tdopen >}}
Leader election in rings. Basic computational tasks in general synchronous networks: leader election. Breadth-first search. Broadcast and convergecast. Shortest paths.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec02))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
3
{{< tdclose >}}
{{< tdopen >}}
Spanning trees. Minimum spanning trees.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec03))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
4
{{< tdclose >}}
{{< tdopen >}}
Fault-tolerant consensus. Link failures: the two generals problem. Process failures (stopping, Byzantine). Algorithms for agreement with stopping and Byzantine failures. Exponential information gathering.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec04))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
5
{{< tdclose >}}
{{< tdopen >}}
Number-of-processor bounds for Byzantine agreement. Weak Byzantine agreement. Time bounds for consensus problems.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec05))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
6
{{< tdclose >}}
{{< tdopen >}}
_k_\-set-agreement. Approximate agreement. Distributed commit.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec06))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
7
{{< tdclose >}}
{{< tdopen >}}
Asynchronous distributed computing. Formal modeling of asynchronous systems using interacting state machines (I/O automata). Proving correctness of distributed algorithms.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec07))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
8
{{< tdclose >}}
{{< tdopen >}}
Non-fault-tolerant algorithms for asynchronous networks. Leader election, breadth-first search, shortest paths, broadcast and convergecast.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec08))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
9
{{< tdclose >}}
{{< tdopen >}}
Spanning trees. Gallager _et al_. minimum spanning trees.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec09))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
10
{{< tdclose >}}
{{< tdopen >}}
Synchronizers. Synchronizer applications. Synchronous vs. asynchronous distributed systems.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec10))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
11
{{< tdclose >}}
{{< tdopen >}}
Time, clocks, and the ordering of events. State-machine simulation. Vector timestamps.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec11))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
12
{{< tdclose >}}
{{< tdopen >}}
Stable property detection. Distributed termination. Global snapshots. Deadlock detection.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec12))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
13
{{< tdclose >}}
{{< tdopen >}}
Asynchronous shared-memory systems. The mutual exclusion problem. Mutual exclusion algorithms.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec13))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
14
{{< tdclose >}}
{{< tdopen >}}
More mutual exclusion algorithms. Bounds on shared memory for mutual exclusion. Resource allocation. The Dining Philosophers problem.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec14))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
15
{{< tdclose >}}
{{< tdopen >}}
Shared-memory multiprocessors. Contention, caching, locality. Practical mutual exclusion algorithms. Reading/writing locks.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec15))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
16
{{< tdclose >}}
{{< tdopen >}}
Impossibility of consensus in asynchronous, fault-prone, shared-memory systems.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec16))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
17
{{< tdclose >}}
{{< tdopen >}}
Atomic objects
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec17))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
18
{{< tdclose >}}
{{< tdopen >}}
Atomic snapshot algorithms. Atomic read/write register algorithms.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec18))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
19
{{< tdclose >}}
{{< tdopen >}}
List algorithms: locking algorithms, optimistic algorithms, lock-free algorithms, lazy algorithms.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec19))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
20
{{< tdclose >}}
{{< tdopen >}}
Transactional memory: obstruction-free and lock-based implementations.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec20))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
21
{{< tdclose >}}
{{< tdopen >}}
Wait-free computability. The wait-free consensus hierarchy.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec21))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
22
{{< tdclose >}}
{{< tdopen >}}
Wait-free vs. _f_\-fault-tolerant atomic objects. Boosting fault-tolerance.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec22))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
23
{{< tdclose >}}
{{< tdopen >}}
Asynchronous network model vs. asynchronous shared-memory model. Impossibility of consensus in asynchronous networks. Failure detectors and consensus. Paxos consensus algorithm.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec23))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
24
{{< tdclose >}}
{{< tdopen >}}
Self-stabilizing algorithms
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec24))
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
25
{{< tdclose >}}
{{< tdopen >}}
Timing-based systems. Modeling and verification. Timing-based algorithms for mutual exclusion and consensus. Clock synchronization.
{{< tdclose >}}
{{< tdopen >}}
([PDF]({{< baseurl >}}/resources/mit6_852jf09_lec25))
{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}